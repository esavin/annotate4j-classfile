package annotate4j.classfile.structure;

import annotate4j.classfile.structure.attribute.Attribute;
import annotate4j.classfile.structure.attribute.ExceptionsAttribute;
import annotate4j.classfile.structure.constantpool.ConstantPoolItem;
import annotate4j.classfile.structure.constantpool.Utf8Info;
import annotate4j.classfile.structure.types.Type;
import annotate4j.classfile.structure.types.TypeList;
import annotate4j.classfile.utils.ConstantPoolUtils;
import annotate4j.core.Loader;
import annotate4j.core.bin.annotation.ContainerSize;
import annotate4j.core.bin.annotation.FieldOrder;
import annotate4j.core.bin.annotation.Inject;
import annotate4j.core.bin.exceptions.FieldReadException;
import annotate4j.core.bin.loader.InputStreamLoader;

import java.io.ByteArrayInputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Eugene Savin
 */
public class Method implements HasDescriptorIndex, HasAttributeList {
    private final static Map<Short, String> methodAccessAndPropertyFlags;
    static {
     methodAccessAndPropertyFlags = new HashMap<>();
        methodAccessAndPropertyFlags.put((short) 0x0001, "public");
        methodAccessAndPropertyFlags.put((short) 0x0002, "private");
        methodAccessAndPropertyFlags.put((short)0x0004, "protected");
        methodAccessAndPropertyFlags.put((short)0x0008, "static");
        methodAccessAndPropertyFlags.put((short)0x0010, "final");
        methodAccessAndPropertyFlags.put((short)0x0020, "synchronized");
        methodAccessAndPropertyFlags.put((short)0x0040, "ACC_BRIDGE"); // A bridge method, generated by the compiler.
        methodAccessAndPropertyFlags.put((short)0x0080, "ACC_VARARGS"); //Declared with variable number of arguments.
        methodAccessAndPropertyFlags.put((short)0x0100, "native");
        methodAccessAndPropertyFlags.put((short)0x0400, "abstract");
        methodAccessAndPropertyFlags.put((short)0x0800, "strictfp");
        methodAccessAndPropertyFlags.put((short)0x1000, "ACC_SYNTHETIC"); // Declared synthetic; not present in the source code.
    }

    private Short thisClassIndex;


    @FieldOrder(index = 1)
    private short accessFlags;

    @FieldOrder(index = 2)
    private short nameIndex;

    @FieldOrder(index = 3)
    private Short descriptorIndex;

    @FieldOrder(index = 4)
    private short attributesCount;

    @FieldOrder(index = 5)
    @ContainerSize(fieldName = "attributesCount")
    @Inject(fieldName = "constantPoolList")
    private List<Attribute> attributeList;

    protected List<ConstantPoolItem> constantPoolList;

    public short getAccessFlags() {
        return accessFlags;
    }

    public void setAccessFlags(short accessFlags) {
        this.accessFlags = accessFlags;
    }

    public List<Attribute> getAttributeList() {
        return attributeList;
    }

    public void setAttributeList(List<Attribute> attributeList) {
        this.attributeList = attributeList;
    }

    public static TypeList getTypeList(String descriptor){
        Loader loader = new InputStreamLoader(new ByteArrayInputStream(descriptor.getBytes()), new TypeList());
        TypeList typeList = null;
        try {
            typeList = (TypeList) loader.load();
        } catch (FieldReadException e) {
            e.printStackTrace();
        }
        return typeList;
    }

    public short getAttributesCount() {
        return attributesCount;
    }

    public void setAttributesCount(short attributesCount) {
        this.attributesCount = attributesCount;
    }

    public Short getDescriptorIndex() {
        return descriptorIndex;
    }

    public void setDescriptorIndex(Short descriptorIndex) {
        this.descriptorIndex = descriptorIndex;
    }

    public short getNameIndex() {
        return nameIndex;
    }

    public void setNameIndex(short nameIndex) {
        this.nameIndex = nameIndex;
    }

    public String getMethodAccessProperties(){
        StringBuilder builder = new StringBuilder();
        for (Map.Entry<Short, String> e: methodAccessAndPropertyFlags.entrySet()){
            if ((e.getKey() & accessFlags) == e.getKey()){
                builder.append(e.getValue()).append(" ");
            }
        }
        if (builder.length() > 0) {
            builder.setLength(builder.length() - 1);
        }
        return builder.toString();
    }

    public String getMethodName(){
        Utf8Info name = (Utf8Info) getConstantPoolList().get(nameIndex - 1);
        String methodName = name.getBytesStr();
        if (methodName.equals("<init>")){
            methodName = constantPoolList.get(getThisClassIndex() - 1).toString();
            if (methodName.contains("/")) {
                methodName = methodName.substring(methodName.lastIndexOf("/") + 1);
            }
        }
        if (methodName.equals("<clinit>")){
            return "";
        }
        return methodName;
    }

    public String getDescription(){
        Utf8Info name = (Utf8Info) getConstantPoolList().get(descriptorIndex - 1);
        return name.getBytesStr();
    }

    public List<ConstantPoolItem> getConstantPoolList() {
        return constantPoolList;
    }

    public void setConstantPoolList(List<ConstantPoolItem> constantPoolList) {
        this.constantPoolList = constantPoolList;
    }

    public Short getThisClassIndex() {
        return thisClassIndex;
    }

    public void setThisClassIndex(Short thisClassIndex) {
        this.thisClassIndex = thisClassIndex;
    }

    public String getReturnValue() {
        String description = getDescription();

        int index = description.lastIndexOf(')');
        description = description.substring(index + 1);
        if (description.equals("V")){
            Utf8Info name = (Utf8Info) getConstantPoolList().get(nameIndex - 1);
            String methodName = name.getBytesStr();
            if (methodName.equals("<init>") || methodName.equals("<clinit>")){
                return "";
            }
            return "void";
        }
        return  Field.getType(description);
    }

    public String getMethodParams() {
        String description = getDescription();
        int from = description.lastIndexOf('(');
        int to = description.lastIndexOf(')');
        return description.substring(from + 1, to);
    }

    @Override
    public String toString() {

        StringBuilder params = new StringBuilder();
        int index = 1;
        TypeList typeList = getTypeList(getMethodParams());
        for (Type type: typeList.getTypeList()){
            params.append(type.getTypeName()).append(" param").append(index).append(", ");
            index++;
        }
        if (params.length() > 2){
            params.setLength(params.length() - 2);
        }
        String throwsClause = "";
        for (Attribute attribute : getAttributeList()) {
            if (attribute instanceof ExceptionsAttribute) {
                ExceptionsAttribute eAttribute = (ExceptionsAttribute) attribute;
                StringBuilder builder = new StringBuilder();
                for (short idx : eAttribute.getExceptionIndexTable()) {
                    builder.append(ConstantPoolUtils.getStringByIndex(idx, constantPoolList));
                    builder.append(", ");
                }
                if (builder.length() > 0) {
                    builder.setLength(builder.length() - 2);
                }
                throwsClause = " throws " + builder.toString();
            }
        }

        return getMethodAccessProperties() + " " + getReturnValue() +
                " " + getMethodName() + " "
                + "(" + params.toString() + ")" + throwsClause;

    }
}
