package annotate4j.classfile.structure;

import annotate4j.classfile.structure.attribute.Attribute;
import annotate4j.classfile.structure.constantpool.ConstantPool;
import annotate4j.classfile.structure.constantpool.Utf8Info;
import annotate4j.core.annotation.FieldOrder;
import annotate4j.core.bin.annotation.ContainerSize;
import annotate4j.core.bin.annotation.Inject;

import javax.annotation.PostConstruct;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Eugene Savin
 */
public class Method implements HasDescriptorIndex, HasAttributeList {
    private final static Map<Short, String> methodAccessAndPropertyFlags;
    static {
     methodAccessAndPropertyFlags = new HashMap<>();
        methodAccessAndPropertyFlags.put((short) 0x0001, "public");
        methodAccessAndPropertyFlags.put((short) 0x0002, "private");
        methodAccessAndPropertyFlags.put((short)0x0004, "protected");
        methodAccessAndPropertyFlags.put((short)0x0008, "static");
        methodAccessAndPropertyFlags.put((short)0x0010, "final");
        methodAccessAndPropertyFlags.put((short)0x0020, "synchronized");
        methodAccessAndPropertyFlags.put((short)0x0040, "ACC_BRIDGE"); // A bridge method, generated by the compiler.
        methodAccessAndPropertyFlags.put((short)0x0080, "ACC_VARARGS"); //Declared with variable number of arguments.
        methodAccessAndPropertyFlags.put((short)0x0100, "native");
        methodAccessAndPropertyFlags.put((short)0x0400, "abstract");
        methodAccessAndPropertyFlags.put((short)0x0800, "strictfp");
        methodAccessAndPropertyFlags.put((short)0x1000, "ACC_SYNTHETIC"); // Declared synthetic; not present in the source code.
    }


    @FieldOrder(index = 1)
    private short accessFlags;

    @FieldOrder(index = 2)
    private short nameIndex;

    @FieldOrder(index = 3)
    private Short descriptorIndex;

    @FieldOrder(index = 4)
    private short attributesCount;

    @FieldOrder(index = 5)
    @ContainerSize(fieldName = "attributesCount")
    @Inject(fieldName = "constantPoolList")
    private List<Attribute> attributeList;

    protected List<ConstantPool> constantPoolList;

    public short getAccessFlags() {
        return accessFlags;
    }

    public void setAccessFlags(short accessFlags) {
        this.accessFlags = accessFlags;
    }

    public List<Attribute> getAttributeList() {
        return attributeList;
    }

    public void setAttributeList(List<Attribute> attributeList) {
        this.attributeList = attributeList;
    }

    public short getAttributesCount() {
        return attributesCount;
    }

    public void setAttributesCount(short attributesCount) {
        this.attributesCount = attributesCount;
    }

    public Short getDescriptorIndex() {
        return descriptorIndex;
    }

    public void setDescriptorIndex(Short descriptorIndex) {
        this.descriptorIndex = descriptorIndex;
    }

    public short getNameIndex() {
        return nameIndex;
    }

    public void setNameIndex(short nameIndex) {
        this.nameIndex = nameIndex;
    }

    public String getMethodAccessProperties(){
        StringBuilder builder = new StringBuilder();
        for (Map.Entry<Short, String> e: methodAccessAndPropertyFlags.entrySet()){
            if ((e.getKey() & accessFlags) == e.getKey()){
                builder.append(e.getValue()).append(" ");
            }
        }
        return builder.toString();
    }

    public String getMethodName(){
        Utf8Info name = (Utf8Info) getConstantPoolList().get(nameIndex - 1);
        return name.getBytesStr();
    }

    public String getDescription(){
        Utf8Info name = (Utf8Info) getConstantPoolList().get(descriptorIndex - 1);
        return name.getBytesStr();
    }

    public List<ConstantPool> getConstantPoolList() {
        return constantPoolList;
    }

    @PostConstruct
    public void setConstantPoolList(List<ConstantPool> constantPoolList) {
        this.constantPoolList = constantPoolList;
    }

    private String getReturnValue(){
        String description = getDescription();
        int index = description.lastIndexOf(')');
        return description.substring(index + 2).replaceAll("/", ".").replaceAll(";", " ");

    }

    private String getMethodParams() {
        String description = getDescription();
        int from = description.lastIndexOf('(');
        int to = description.lastIndexOf(')');
        return description.substring(from, to + 1).replaceAll("/", ".").replaceAll(";", " ").replaceAll("\\(L", "(");
    }

    @Override
    public String toString() {


        return getMethodAccessProperties() + " " + getReturnValue() +
                " " + getMethodName() + " "
                 + getMethodParams();

    }
}
